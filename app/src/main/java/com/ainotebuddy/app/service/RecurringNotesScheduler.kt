package com.ainotebuddy.app.service

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import androidx.core.app.NotificationCompat
import androidx.work.*
import com.ainotebuddy.app.MainActivity
import com.ainotebuddy.app.R
import com.ainotebuddy.app.data.model.organization.RecurrencePattern
import com.ainotebuddy.app.data.repository.NoteRepository
import com.ainotebuddy.app.data.repository.organization.RecurringNotesRepository
import com.ainotebuddy.app.di.ApplicationScope
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.time.ZoneId
import java.util.*
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Service responsible for scheduling and executing recurring notes
 */
@Singleton
class RecurringNotesScheduler @Inject constructor(
    @ApplicationContext private val context: Context,
    private val workManager: WorkManager,
    private val recurringNotesRepository: RecurringNotesRepository,
    private val noteRepository: NoteRepository,
    @ApplicationScope private val applicationScope: CoroutineScope
) {
    private val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    
    init {
        createNotificationChannel()
        scheduleDailyCheck()
    }
    
    /**
     * Schedule a new recurring note
     */
    fun scheduleRecurringNote(pattern: RecurrencePattern) {
        applicationScope.launch {
            // Update the next run time
            val nextRun = pattern.nextOccurrence() ?: return@launch
            scheduleNextRun(pattern.id, nextRun)
        }
    }
    
    /**
     * Cancel a scheduled recurring note
     */
    fun cancelRecurringNote(patternId: Long) {
        workManager.cancelAllWorkByTag(getWorkName(patternId))
    }
    
    /**
     * Check for and process any recurring notes that are due
     */
    suspend fun checkAndProcessRecurringNotes() {
        val today = LocalDate.now()
        val patterns = recurringNotesRepository.getRecurrencePatternsForDate(today)
        
        patterns.forEach { pattern ->
            if (pattern.shouldRunOn(today)) {
                processRecurringNote(pattern)
                
                // Update last run time
                recurringNotesRepository.updateLastRun(pattern.id, today)
                
                // Schedule next occurrence
                val nextRun = pattern.nextOccurrence(today.plusDays(1))
                if (nextRun != null) {
                    scheduleNextRun(pattern.id, nextRun)
                }
            }
        }
    }
    
    private suspend fun processRecurringNote(pattern: RecurrencePattern) {
        try {
            // Get the original note
            val originalNote = noteRepository.getNoteById(pattern.noteId.toString()) ?: return
            
            // Create a copy of the note with updated dates
            val newNote = originalNote.copy(
                id = 0, // New ID will be generated by the database
                title = "${originalNote.title} (${LocalDate.now().format(java.time.format.DateTimeFormatter.ISO_LOCAL_DATE)})",
                dateCreated = System.currentTimeMillis(),
                dateModified = System.currentTimeMillis()
            )
            
            // Save the new note
            noteRepository.insertNote(newNote)
            
            // Show notification
            showNotification(
                context.getString(R.string.new_recurring_note_created),
                context.getString(R.string.new_note_created_from_template, originalNote.title)
            )
            
        } catch (e: Exception) {
            // Log error and show notification
            showNotification(
                context.getString(R.string.error_creating_recurring_note),
                e.message ?: context.getString(R.string.unknown_error)
            )
        }
    }
    
    private fun scheduleNextRun(patternId: Long, date: LocalDate) {
        val now = LocalDateTime.now()
        val scheduledTime = date.atTime(LocalTime.MIDNIGHT.plusHours(8)) // Default to 8 AM
        
        // Calculate delay in milliseconds
        val delay = scheduledTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli() - 
                   now.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli()
        
        if (delay <= 0) return // Skip if the time has already passed
        
        // Create work request
        val workRequest = OneTimeWorkRequestBuilder<RecurringNoteWorker>()
            .setInitialDelay(delay, TimeUnit.MILLISECONDS)
            .setInputData(workDataOf("pattern_id" to patternId))
            .addTag(getWorkName(patternId))
            .build()
        
        // Enqueue the work
        workManager.enqueue(workRequest)
    }
    
    private fun scheduleDailyCheck() {
        // Cancel any existing daily checks
        workManager.cancelAllWorkByTag(DAILY_CHECK_TAG)
        
        // Schedule a daily check at midnight
        val dailyCheckRequest = PeriodicWorkRequestBuilder<DailyCheckWorker>(
            repeatInterval = 1, 
            repeatIntervalTimeUnit = TimeUnit.DAYS
        )
            .setInitialDelay(1, TimeUnit.MINUTES) // Start after 1 minute
            .addTag(DAILY_CHECK_TAG)
            .build()
        
        workManager.enqueue(dailyCheckRequest)
    }
    
    private fun showNotification(title: String, message: String) {
        val notificationId = System.currentTimeMillis().toInt()
        
        // Create an intent to open the app when the notification is tapped
        val intent = Intent(context, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }
        
        val pendingIntent = PendingIntent.getActivity(
            context, 0, intent, 
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        // Build the notification
        val notification = NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle(title)
            .setContentText(message)
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .build()
        
        // Show the notification
        notificationManager.notify(notificationId, notification)
    }
    
    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = context.getString(R.string.recurring_notes_channel_name)
            val descriptionText = context.getString(R.string.recurring_notes_channel_description)
            val importance = NotificationManager.IMPORTANCE_DEFAULT
            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {
                description = descriptionText
            }
            notificationManager.createNotificationChannel(channel)
        }
    }
    
    private fun getWorkName(patternId: Long): String {
        return "recurring_note_$patternId"
    }
    
    companion object {
        private const val CHANNEL_ID = "recurring_notes_channel"
        private const val DAILY_CHECK_TAG = "daily_recurring_notes_check"
    }
}

/**
 * Worker class for processing recurring notes
 */
class RecurringNoteWorker(
    context: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(context, workerParams) {
    
    @Inject
    lateinit var recurringNotesScheduler: RecurringNotesScheduler
    
    override suspend fun doWork(): Result {
        val patternId = inputData.getLong("pattern_id", 0L)
        if (patternId == 0L) return Result.failure()
        
        return try {
            recurringNotesScheduler.checkAndProcessRecurringNotes()
            Result.success()
        } catch (e: Exception) {
            Result.retry()
        }
    }
}

/**
 * Worker for daily checks of recurring notes
 */
class DailyCheckWorker(
    context: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(context, workerParams) {
    
    @Inject
    lateinit var recurringNotesScheduler: RecurringNotesScheduler
    
    override suspend fun doWork(): Result {
        return try {
            recurringNotesScheduler.checkAndProcessRecurringNotes()
            Result.success()
        } catch (e: Exception) {
            Result.retry()
        }
    }
}
